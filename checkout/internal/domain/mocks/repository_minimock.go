// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i route256/checkout/internal/domain.Repository -o repository_minimock.go -n RepositoryMock -p mocks

import (
	"context"
	mm_domain "route256/checkout/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_domain.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateCartItem          func(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error)
	funcCreateCartItemOrigin    string
	inspectFuncCreateCartItem   func(ctx context.Context, cartItem mm_domain.CartItemDiff)
	afterCreateCartItemCounter  uint64
	beforeCreateCartItemCounter uint64
	CreateCartItemMock          mRepositoryMockCreateCartItem

	funcDeleteCart          func(ctx context.Context, user int64) (err error)
	funcDeleteCartOrigin    string
	inspectFuncDeleteCart   func(ctx context.Context, user int64)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mRepositoryMockDeleteCart

	funcDeleteFromCart          func(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error)
	funcDeleteFromCartOrigin    string
	inspectFuncDeleteFromCart   func(ctx context.Context, cartItem mm_domain.CartItemDiff)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mRepositoryMockDeleteFromCart

	funcGetCartItem          func(ctx context.Context, user int64, sku uint32) (c2 mm_domain.CartItemDiff, err error)
	funcGetCartItemOrigin    string
	inspectFuncGetCartItem   func(ctx context.Context, user int64, sku uint32)
	afterGetCartItemCounter  uint64
	beforeGetCartItemCounter uint64
	GetCartItemMock          mRepositoryMockGetCartItem

	funcListCart          func(ctx context.Context, user int64) (ca1 []mm_domain.CartItemDiff, err error)
	funcListCartOrigin    string
	inspectFuncListCart   func(ctx context.Context, user int64)
	afterListCartCounter  uint64
	beforeListCartCounter uint64
	ListCartMock          mRepositoryMockListCart

	funcUpdateCartItemCount          func(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) (err error)
	funcUpdateCartItemCountOrigin    string
	inspectFuncUpdateCartItemCount   func(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16)
	afterUpdateCartItemCountCounter  uint64
	beforeUpdateCartItemCountCounter uint64
	UpdateCartItemCountMock          mRepositoryMockUpdateCartItemCount
}

// NewRepositoryMock returns a mock for mm_domain.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCartItemMock = mRepositoryMockCreateCartItem{mock: m}
	m.CreateCartItemMock.callArgs = []*RepositoryMockCreateCartItemParams{}

	m.DeleteCartMock = mRepositoryMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*RepositoryMockDeleteCartParams{}

	m.DeleteFromCartMock = mRepositoryMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*RepositoryMockDeleteFromCartParams{}

	m.GetCartItemMock = mRepositoryMockGetCartItem{mock: m}
	m.GetCartItemMock.callArgs = []*RepositoryMockGetCartItemParams{}

	m.ListCartMock = mRepositoryMockListCart{mock: m}
	m.ListCartMock.callArgs = []*RepositoryMockListCartParams{}

	m.UpdateCartItemCountMock = mRepositoryMockUpdateCartItemCount{mock: m}
	m.UpdateCartItemCountMock.callArgs = []*RepositoryMockUpdateCartItemCountParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCreateCartItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateCartItemExpectation
	expectations       []*RepositoryMockCreateCartItemExpectation

	callArgs []*RepositoryMockCreateCartItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateCartItemExpectation specifies expectation struct of the Repository.CreateCartItem
type RepositoryMockCreateCartItemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateCartItemParams
	paramPtrs          *RepositoryMockCreateCartItemParamPtrs
	expectationOrigins RepositoryMockCreateCartItemExpectationOrigins
	results            *RepositoryMockCreateCartItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateCartItemParams contains parameters of the Repository.CreateCartItem
type RepositoryMockCreateCartItemParams struct {
	ctx      context.Context
	cartItem mm_domain.CartItemDiff
}

// RepositoryMockCreateCartItemParamPtrs contains pointers to parameters of the Repository.CreateCartItem
type RepositoryMockCreateCartItemParamPtrs struct {
	ctx      *context.Context
	cartItem *mm_domain.CartItemDiff
}

// RepositoryMockCreateCartItemResults contains results of the Repository.CreateCartItem
type RepositoryMockCreateCartItemResults struct {
	err error
}

// RepositoryMockCreateCartItemOrigins contains origins of expectations of the Repository.CreateCartItem
type RepositoryMockCreateCartItemExpectationOrigins struct {
	origin         string
	originCtx      string
	originCartItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Optional() *mRepositoryMockCreateCartItem {
	mmCreateCartItem.optional = true
	return mmCreateCartItem
}

// Expect sets up expected params for Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Expect(ctx context.Context, cartItem mm_domain.CartItemDiff) *mRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &RepositoryMockCreateCartItemExpectation{}
	}

	if mmCreateCartItem.defaultExpectation.paramPtrs != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by ExpectParams functions")
	}

	mmCreateCartItem.defaultExpectation.params = &RepositoryMockCreateCartItemParams{ctx, cartItem}
	mmCreateCartItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateCartItem.expectations {
		if minimock.Equal(e.params, mmCreateCartItem.defaultExpectation.params) {
			mmCreateCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCartItem.defaultExpectation.params)
		}
	}

	return mmCreateCartItem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &RepositoryMockCreateCartItemExpectation{}
	}

	if mmCreateCartItem.defaultExpectation.params != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Expect")
	}

	if mmCreateCartItem.defaultExpectation.paramPtrs == nil {
		mmCreateCartItem.defaultExpectation.paramPtrs = &RepositoryMockCreateCartItemParamPtrs{}
	}
	mmCreateCartItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateCartItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateCartItem
}

// ExpectCartItemParam2 sets up expected param cartItem for Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) ExpectCartItemParam2(cartItem mm_domain.CartItemDiff) *mRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &RepositoryMockCreateCartItemExpectation{}
	}

	if mmCreateCartItem.defaultExpectation.params != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Expect")
	}

	if mmCreateCartItem.defaultExpectation.paramPtrs == nil {
		mmCreateCartItem.defaultExpectation.paramPtrs = &RepositoryMockCreateCartItemParamPtrs{}
	}
	mmCreateCartItem.defaultExpectation.paramPtrs.cartItem = &cartItem
	mmCreateCartItem.defaultExpectation.expectationOrigins.originCartItem = minimock.CallerInfo(1)

	return mmCreateCartItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Inspect(f func(ctx context.Context, cartItem mm_domain.CartItemDiff)) *mRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.inspectFuncCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateCartItem")
	}

	mmCreateCartItem.mock.inspectFuncCreateCartItem = f

	return mmCreateCartItem
}

// Return sets up results that will be returned by Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Return(err error) *RepositoryMock {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &RepositoryMockCreateCartItemExpectation{mock: mmCreateCartItem.mock}
	}
	mmCreateCartItem.defaultExpectation.results = &RepositoryMockCreateCartItemResults{err}
	mmCreateCartItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateCartItem.mock
}

// Set uses given function f to mock the Repository.CreateCartItem method
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Set(f func(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error)) *RepositoryMock {
	if mmCreateCartItem.defaultExpectation != nil {
		mmCreateCartItem.mock.t.Fatalf("Default expectation is already set for the Repository.CreateCartItem method")
	}

	if len(mmCreateCartItem.expectations) > 0 {
		mmCreateCartItem.mock.t.Fatalf("Some expectations are already set for the Repository.CreateCartItem method")
	}

	mmCreateCartItem.mock.funcCreateCartItem = f
	mmCreateCartItem.mock.funcCreateCartItemOrigin = minimock.CallerInfo(1)
	return mmCreateCartItem.mock
}

// When sets expectation for the Repository.CreateCartItem which will trigger the result defined by the following
// Then helper
func (mmCreateCartItem *mRepositoryMockCreateCartItem) When(ctx context.Context, cartItem mm_domain.CartItemDiff) *RepositoryMockCreateCartItemExpectation {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	expectation := &RepositoryMockCreateCartItemExpectation{
		mock:               mmCreateCartItem.mock,
		params:             &RepositoryMockCreateCartItemParams{ctx, cartItem},
		expectationOrigins: RepositoryMockCreateCartItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateCartItem.expectations = append(mmCreateCartItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateCartItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateCartItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateCartItemResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateCartItem should be invoked
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Times(n uint64) *mRepositoryMockCreateCartItem {
	if n == 0 {
		mmCreateCartItem.mock.t.Fatalf("Times of RepositoryMock.CreateCartItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateCartItem.expectedInvocations, n)
	mmCreateCartItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateCartItem
}

func (mmCreateCartItem *mRepositoryMockCreateCartItem) invocationsDone() bool {
	if len(mmCreateCartItem.expectations) == 0 && mmCreateCartItem.defaultExpectation == nil && mmCreateCartItem.mock.funcCreateCartItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateCartItem.mock.afterCreateCartItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateCartItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateCartItem implements mm_domain.Repository
func (mmCreateCartItem *RepositoryMock) CreateCartItem(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error) {
	mm_atomic.AddUint64(&mmCreateCartItem.beforeCreateCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCartItem.afterCreateCartItemCounter, 1)

	mmCreateCartItem.t.Helper()

	if mmCreateCartItem.inspectFuncCreateCartItem != nil {
		mmCreateCartItem.inspectFuncCreateCartItem(ctx, cartItem)
	}

	mm_params := RepositoryMockCreateCartItemParams{ctx, cartItem}

	// Record call args
	mmCreateCartItem.CreateCartItemMock.mutex.Lock()
	mmCreateCartItem.CreateCartItemMock.callArgs = append(mmCreateCartItem.CreateCartItemMock.callArgs, &mm_params)
	mmCreateCartItem.CreateCartItemMock.mutex.Unlock()

	for _, e := range mmCreateCartItem.CreateCartItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateCartItem.CreateCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCartItem.CreateCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCartItem.CreateCartItemMock.defaultExpectation.params
		mm_want_ptrs := mmCreateCartItem.CreateCartItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateCartItemParams{ctx, cartItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateCartItem.t.Errorf("RepositoryMock.CreateCartItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCartItem.CreateCartItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItem != nil && !minimock.Equal(*mm_want_ptrs.cartItem, mm_got.cartItem) {
				mmCreateCartItem.t.Errorf("RepositoryMock.CreateCartItem got unexpected parameter cartItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateCartItem.CreateCartItemMock.defaultExpectation.expectationOrigins.originCartItem, *mm_want_ptrs.cartItem, mm_got.cartItem, minimock.Diff(*mm_want_ptrs.cartItem, mm_got.cartItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCartItem.t.Errorf("RepositoryMock.CreateCartItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateCartItem.CreateCartItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCartItem.CreateCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCartItem.t.Fatal("No results are set for the RepositoryMock.CreateCartItem")
		}
		return (*mm_results).err
	}
	if mmCreateCartItem.funcCreateCartItem != nil {
		return mmCreateCartItem.funcCreateCartItem(ctx, cartItem)
	}
	mmCreateCartItem.t.Fatalf("Unexpected call to RepositoryMock.CreateCartItem. %v %v", ctx, cartItem)
	return
}

// CreateCartItemAfterCounter returns a count of finished RepositoryMock.CreateCartItem invocations
func (mmCreateCartItem *RepositoryMock) CreateCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCartItem.afterCreateCartItemCounter)
}

// CreateCartItemBeforeCounter returns a count of RepositoryMock.CreateCartItem invocations
func (mmCreateCartItem *RepositoryMock) CreateCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCartItem.beforeCreateCartItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Calls() []*RepositoryMockCreateCartItemParams {
	mmCreateCartItem.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateCartItemParams, len(mmCreateCartItem.callArgs))
	copy(argCopy, mmCreateCartItem.callArgs)

	mmCreateCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCartItemDone returns true if the count of the CreateCartItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateCartItemDone() bool {
	if m.CreateCartItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCartItemMock.invocationsDone()
}

// MinimockCreateCartItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateCartItemInspect() {
	for _, e := range m.CreateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateCartItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCartItemCounter := mm_atomic.LoadUint64(&m.afterCreateCartItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartItemMock.defaultExpectation != nil && afterCreateCartItemCounter < 1 {
		if m.CreateCartItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateCartItem at\n%s", m.CreateCartItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateCartItem at\n%s with params: %#v", m.CreateCartItemMock.defaultExpectation.expectationOrigins.origin, *m.CreateCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCartItem != nil && afterCreateCartItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateCartItem at\n%s", m.funcCreateCartItemOrigin)
	}

	if !m.CreateCartItemMock.invocationsDone() && afterCreateCartItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateCartItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCartItemMock.expectedInvocations), m.CreateCartItemMock.expectedInvocationsOrigin, afterCreateCartItemCounter)
	}
}

type mRepositoryMockDeleteCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteCartExpectation
	expectations       []*RepositoryMockDeleteCartExpectation

	callArgs []*RepositoryMockDeleteCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteCartExpectation specifies expectation struct of the Repository.DeleteCart
type RepositoryMockDeleteCartExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteCartParams
	paramPtrs          *RepositoryMockDeleteCartParamPtrs
	expectationOrigins RepositoryMockDeleteCartExpectationOrigins
	results            *RepositoryMockDeleteCartResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteCartParams contains parameters of the Repository.DeleteCart
type RepositoryMockDeleteCartParams struct {
	ctx  context.Context
	user int64
}

// RepositoryMockDeleteCartParamPtrs contains pointers to parameters of the Repository.DeleteCart
type RepositoryMockDeleteCartParamPtrs struct {
	ctx  *context.Context
	user *int64
}

// RepositoryMockDeleteCartResults contains results of the Repository.DeleteCart
type RepositoryMockDeleteCartResults struct {
	err error
}

// RepositoryMockDeleteCartOrigins contains origins of expectations of the Repository.DeleteCart
type RepositoryMockDeleteCartExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteCart *mRepositoryMockDeleteCart) Optional() *mRepositoryMockDeleteCart {
	mmDeleteCart.optional = true
	return mmDeleteCart
}

// Expect sets up expected params for Repository.DeleteCart
func (mmDeleteCart *mRepositoryMockDeleteCart) Expect(ctx context.Context, user int64) *mRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &RepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.paramPtrs != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by ExpectParams functions")
	}

	mmDeleteCart.defaultExpectation.params = &RepositoryMockDeleteCartParams{ctx, user}
	mmDeleteCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteCart
func (mmDeleteCart *mRepositoryMockDeleteCart) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &RepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &RepositoryMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteCart
}

// ExpectUserParam2 sets up expected param user for Repository.DeleteCart
func (mmDeleteCart *mRepositoryMockDeleteCart) ExpectUserParam2(user int64) *mRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &RepositoryMockDeleteCartExpectation{}
	}

	if mmDeleteCart.defaultExpectation.params != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Expect")
	}

	if mmDeleteCart.defaultExpectation.paramPtrs == nil {
		mmDeleteCart.defaultExpectation.paramPtrs = &RepositoryMockDeleteCartParamPtrs{}
	}
	mmDeleteCart.defaultExpectation.paramPtrs.user = &user
	mmDeleteCart.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteCart
func (mmDeleteCart *mRepositoryMockDeleteCart) Inspect(f func(ctx context.Context, user int64)) *mRepositoryMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by Repository.DeleteCart
func (mmDeleteCart *mRepositoryMockDeleteCart) Return(err error) *RepositoryMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &RepositoryMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &RepositoryMockDeleteCartResults{err}
	mmDeleteCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// Set uses given function f to mock the Repository.DeleteCart method
func (mmDeleteCart *mRepositoryMockDeleteCart) Set(f func(ctx context.Context, user int64) (err error)) *RepositoryMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	mmDeleteCart.mock.funcDeleteCartOrigin = minimock.CallerInfo(1)
	return mmDeleteCart.mock
}

// When sets expectation for the Repository.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mRepositoryMockDeleteCart) When(ctx context.Context, user int64) *RepositoryMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteCartExpectation{
		mock:               mmDeleteCart.mock,
		params:             &RepositoryMockDeleteCartParams{ctx, user},
		expectationOrigins: RepositoryMockDeleteCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteCartResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteCart should be invoked
func (mmDeleteCart *mRepositoryMockDeleteCart) Times(n uint64) *mRepositoryMockDeleteCart {
	if n == 0 {
		mmDeleteCart.mock.t.Fatalf("Times of RepositoryMock.DeleteCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteCart.expectedInvocations, n)
	mmDeleteCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteCart
}

func (mmDeleteCart *mRepositoryMockDeleteCart) invocationsDone() bool {
	if len(mmDeleteCart.expectations) == 0 && mmDeleteCart.defaultExpectation == nil && mmDeleteCart.mock.funcDeleteCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteCart.mock.afterDeleteCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteCart implements mm_domain.Repository
func (mmDeleteCart *RepositoryMock) DeleteCart(ctx context.Context, user int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	mmDeleteCart.t.Helper()

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, user)
	}

	mm_params := RepositoryMockDeleteCartParams{ctx, user}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, &mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteCart.DeleteCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteCartParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteCart.t.Errorf("RepositoryMock.DeleteCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmDeleteCart.t.Errorf("RepositoryMock.DeleteCart got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("RepositoryMock.DeleteCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteCart.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the RepositoryMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, user)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to RepositoryMock.DeleteCart. %v %v", ctx, user)
	return
}

// DeleteCartAfterCounter returns a count of finished RepositoryMock.DeleteCart invocations
func (mmDeleteCart *RepositoryMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of RepositoryMock.DeleteCart invocations
func (mmDeleteCart *RepositoryMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mRepositoryMockDeleteCart) Calls() []*RepositoryMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteCartDone() bool {
	if m.DeleteCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteCartMock.invocationsDone()
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCartCounter := mm_atomic.LoadUint64(&m.afterDeleteCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && afterDeleteCartCounter < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCart at\n%s", m.DeleteCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCart at\n%s with params: %#v", m.DeleteCartMock.defaultExpectation.expectationOrigins.origin, *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && afterDeleteCartCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteCart at\n%s", m.funcDeleteCartOrigin)
	}

	if !m.DeleteCartMock.invocationsDone() && afterDeleteCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteCartMock.expectedInvocations), m.DeleteCartMock.expectedInvocationsOrigin, afterDeleteCartCounter)
	}
}

type mRepositoryMockDeleteFromCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteFromCartExpectation
	expectations       []*RepositoryMockDeleteFromCartExpectation

	callArgs []*RepositoryMockDeleteFromCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteFromCartExpectation specifies expectation struct of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteFromCartParams
	paramPtrs          *RepositoryMockDeleteFromCartParamPtrs
	expectationOrigins RepositoryMockDeleteFromCartExpectationOrigins
	results            *RepositoryMockDeleteFromCartResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteFromCartParams contains parameters of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartParams struct {
	ctx      context.Context
	cartItem mm_domain.CartItemDiff
}

// RepositoryMockDeleteFromCartParamPtrs contains pointers to parameters of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartParamPtrs struct {
	ctx      *context.Context
	cartItem *mm_domain.CartItemDiff
}

// RepositoryMockDeleteFromCartResults contains results of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartResults struct {
	err error
}

// RepositoryMockDeleteFromCartOrigins contains origins of expectations of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartExpectationOrigins struct {
	origin         string
	originCtx      string
	originCartItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Optional() *mRepositoryMockDeleteFromCart {
	mmDeleteFromCart.optional = true
	return mmDeleteFromCart
}

// Expect sets up expected params for Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Expect(ctx context.Context, cartItem mm_domain.CartItemDiff) *mRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &RepositoryMockDeleteFromCartExpectation{}
	}

	if mmDeleteFromCart.defaultExpectation.paramPtrs != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by ExpectParams functions")
	}

	mmDeleteFromCart.defaultExpectation.params = &RepositoryMockDeleteFromCartParams{ctx, cartItem}
	mmDeleteFromCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &RepositoryMockDeleteFromCartExpectation{}
	}

	if mmDeleteFromCart.defaultExpectation.params != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Expect")
	}

	if mmDeleteFromCart.defaultExpectation.paramPtrs == nil {
		mmDeleteFromCart.defaultExpectation.paramPtrs = &RepositoryMockDeleteFromCartParamPtrs{}
	}
	mmDeleteFromCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteFromCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteFromCart
}

// ExpectCartItemParam2 sets up expected param cartItem for Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) ExpectCartItemParam2(cartItem mm_domain.CartItemDiff) *mRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &RepositoryMockDeleteFromCartExpectation{}
	}

	if mmDeleteFromCart.defaultExpectation.params != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Expect")
	}

	if mmDeleteFromCart.defaultExpectation.paramPtrs == nil {
		mmDeleteFromCart.defaultExpectation.paramPtrs = &RepositoryMockDeleteFromCartParamPtrs{}
	}
	mmDeleteFromCart.defaultExpectation.paramPtrs.cartItem = &cartItem
	mmDeleteFromCart.defaultExpectation.expectationOrigins.originCartItem = minimock.CallerInfo(1)

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Inspect(f func(ctx context.Context, cartItem mm_domain.CartItemDiff)) *mRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Return(err error) *RepositoryMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &RepositoryMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &RepositoryMockDeleteFromCartResults{err}
	mmDeleteFromCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the Repository.DeleteFromCart method
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Set(f func(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error)) *RepositoryMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	mmDeleteFromCart.mock.funcDeleteFromCartOrigin = minimock.CallerInfo(1)
	return mmDeleteFromCart.mock
}

// When sets expectation for the Repository.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) When(ctx context.Context, cartItem mm_domain.CartItemDiff) *RepositoryMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteFromCartExpectation{
		mock:               mmDeleteFromCart.mock,
		params:             &RepositoryMockDeleteFromCartParams{ctx, cartItem},
		expectationOrigins: RepositoryMockDeleteFromCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteFromCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteFromCartResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteFromCart should be invoked
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Times(n uint64) *mRepositoryMockDeleteFromCart {
	if n == 0 {
		mmDeleteFromCart.mock.t.Fatalf("Times of RepositoryMock.DeleteFromCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFromCart.expectedInvocations, n)
	mmDeleteFromCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteFromCart
}

func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) invocationsDone() bool {
	if len(mmDeleteFromCart.expectations) == 0 && mmDeleteFromCart.defaultExpectation == nil && mmDeleteFromCart.mock.funcDeleteFromCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFromCart.mock.afterDeleteFromCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFromCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFromCart implements mm_domain.Repository
func (mmDeleteFromCart *RepositoryMock) DeleteFromCart(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	mmDeleteFromCart.t.Helper()

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, cartItem)
	}

	mm_params := RepositoryMockDeleteFromCartParams{ctx, cartItem}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, &mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteFromCartParams{ctx, cartItem}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFromCart.t.Errorf("RepositoryMock.DeleteFromCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItem != nil && !minimock.Equal(*mm_want_ptrs.cartItem, mm_got.cartItem) {
				mmDeleteFromCart.t.Errorf("RepositoryMock.DeleteFromCart got unexpected parameter cartItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.expectationOrigins.originCartItem, *mm_want_ptrs.cartItem, mm_got.cartItem, minimock.Diff(*mm_want_ptrs.cartItem, mm_got.cartItem))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("RepositoryMock.DeleteFromCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the RepositoryMock.DeleteFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, cartItem)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to RepositoryMock.DeleteFromCart. %v %v", ctx, cartItem)
	return
}

// DeleteFromCartAfterCounter returns a count of finished RepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *RepositoryMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of RepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *RepositoryMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Calls() []*RepositoryMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteFromCartDone() bool {
	if m.DeleteFromCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFromCartMock.invocationsDone()
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFromCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteFromCartCounter := mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && afterDeleteFromCartCounter < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFromCart at\n%s", m.DeleteFromCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFromCart at\n%s with params: %#v", m.DeleteFromCartMock.defaultExpectation.expectationOrigins.origin, *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && afterDeleteFromCartCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteFromCart at\n%s", m.funcDeleteFromCartOrigin)
	}

	if !m.DeleteFromCartMock.invocationsDone() && afterDeleteFromCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteFromCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFromCartMock.expectedInvocations), m.DeleteFromCartMock.expectedInvocationsOrigin, afterDeleteFromCartCounter)
	}
}

type mRepositoryMockGetCartItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCartItemExpectation
	expectations       []*RepositoryMockGetCartItemExpectation

	callArgs []*RepositoryMockGetCartItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetCartItemExpectation specifies expectation struct of the Repository.GetCartItem
type RepositoryMockGetCartItemExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetCartItemParams
	paramPtrs          *RepositoryMockGetCartItemParamPtrs
	expectationOrigins RepositoryMockGetCartItemExpectationOrigins
	results            *RepositoryMockGetCartItemResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetCartItemParams contains parameters of the Repository.GetCartItem
type RepositoryMockGetCartItemParams struct {
	ctx  context.Context
	user int64
	sku  uint32
}

// RepositoryMockGetCartItemParamPtrs contains pointers to parameters of the Repository.GetCartItem
type RepositoryMockGetCartItemParamPtrs struct {
	ctx  *context.Context
	user *int64
	sku  *uint32
}

// RepositoryMockGetCartItemResults contains results of the Repository.GetCartItem
type RepositoryMockGetCartItemResults struct {
	c2  mm_domain.CartItemDiff
	err error
}

// RepositoryMockGetCartItemOrigins contains origins of expectations of the Repository.GetCartItem
type RepositoryMockGetCartItemExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
	originSku  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCartItem *mRepositoryMockGetCartItem) Optional() *mRepositoryMockGetCartItem {
	mmGetCartItem.optional = true
	return mmGetCartItem
}

// Expect sets up expected params for Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) Expect(ctx context.Context, user int64, sku uint32) *mRepositoryMockGetCartItem {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &RepositoryMockGetCartItemExpectation{}
	}

	if mmGetCartItem.defaultExpectation.paramPtrs != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by ExpectParams functions")
	}

	mmGetCartItem.defaultExpectation.params = &RepositoryMockGetCartItemParams{ctx, user, sku}
	mmGetCartItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCartItem.expectations {
		if minimock.Equal(e.params, mmGetCartItem.defaultExpectation.params) {
			mmGetCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItem.defaultExpectation.params)
		}
	}

	return mmGetCartItem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetCartItem {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &RepositoryMockGetCartItemExpectation{}
	}

	if mmGetCartItem.defaultExpectation.params != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Expect")
	}

	if mmGetCartItem.defaultExpectation.paramPtrs == nil {
		mmGetCartItem.defaultExpectation.paramPtrs = &RepositoryMockGetCartItemParamPtrs{}
	}
	mmGetCartItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCartItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCartItem
}

// ExpectUserParam2 sets up expected param user for Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) ExpectUserParam2(user int64) *mRepositoryMockGetCartItem {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &RepositoryMockGetCartItemExpectation{}
	}

	if mmGetCartItem.defaultExpectation.params != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Expect")
	}

	if mmGetCartItem.defaultExpectation.paramPtrs == nil {
		mmGetCartItem.defaultExpectation.paramPtrs = &RepositoryMockGetCartItemParamPtrs{}
	}
	mmGetCartItem.defaultExpectation.paramPtrs.user = &user
	mmGetCartItem.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmGetCartItem
}

// ExpectSkuParam3 sets up expected param sku for Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) ExpectSkuParam3(sku uint32) *mRepositoryMockGetCartItem {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &RepositoryMockGetCartItemExpectation{}
	}

	if mmGetCartItem.defaultExpectation.params != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Expect")
	}

	if mmGetCartItem.defaultExpectation.paramPtrs == nil {
		mmGetCartItem.defaultExpectation.paramPtrs = &RepositoryMockGetCartItemParamPtrs{}
	}
	mmGetCartItem.defaultExpectation.paramPtrs.sku = &sku
	mmGetCartItem.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetCartItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) Inspect(f func(ctx context.Context, user int64, sku uint32)) *mRepositoryMockGetCartItem {
	if mmGetCartItem.mock.inspectFuncGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCartItem")
	}

	mmGetCartItem.mock.inspectFuncGetCartItem = f

	return mmGetCartItem
}

// Return sets up results that will be returned by Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) Return(c2 mm_domain.CartItemDiff, err error) *RepositoryMock {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &RepositoryMockGetCartItemExpectation{mock: mmGetCartItem.mock}
	}
	mmGetCartItem.defaultExpectation.results = &RepositoryMockGetCartItemResults{c2, err}
	mmGetCartItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCartItem.mock
}

// Set uses given function f to mock the Repository.GetCartItem method
func (mmGetCartItem *mRepositoryMockGetCartItem) Set(f func(ctx context.Context, user int64, sku uint32) (c2 mm_domain.CartItemDiff, err error)) *RepositoryMock {
	if mmGetCartItem.defaultExpectation != nil {
		mmGetCartItem.mock.t.Fatalf("Default expectation is already set for the Repository.GetCartItem method")
	}

	if len(mmGetCartItem.expectations) > 0 {
		mmGetCartItem.mock.t.Fatalf("Some expectations are already set for the Repository.GetCartItem method")
	}

	mmGetCartItem.mock.funcGetCartItem = f
	mmGetCartItem.mock.funcGetCartItemOrigin = minimock.CallerInfo(1)
	return mmGetCartItem.mock
}

// When sets expectation for the Repository.GetCartItem which will trigger the result defined by the following
// Then helper
func (mmGetCartItem *mRepositoryMockGetCartItem) When(ctx context.Context, user int64, sku uint32) *RepositoryMockGetCartItemExpectation {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	expectation := &RepositoryMockGetCartItemExpectation{
		mock:               mmGetCartItem.mock,
		params:             &RepositoryMockGetCartItemParams{ctx, user, sku},
		expectationOrigins: RepositoryMockGetCartItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCartItem.expectations = append(mmGetCartItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCartItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCartItemExpectation) Then(c2 mm_domain.CartItemDiff, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCartItemResults{c2, err}
	return e.mock
}

// Times sets number of times Repository.GetCartItem should be invoked
func (mmGetCartItem *mRepositoryMockGetCartItem) Times(n uint64) *mRepositoryMockGetCartItem {
	if n == 0 {
		mmGetCartItem.mock.t.Fatalf("Times of RepositoryMock.GetCartItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCartItem.expectedInvocations, n)
	mmGetCartItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCartItem
}

func (mmGetCartItem *mRepositoryMockGetCartItem) invocationsDone() bool {
	if len(mmGetCartItem.expectations) == 0 && mmGetCartItem.defaultExpectation == nil && mmGetCartItem.mock.funcGetCartItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCartItem.mock.afterGetCartItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCartItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCartItem implements mm_domain.Repository
func (mmGetCartItem *RepositoryMock) GetCartItem(ctx context.Context, user int64, sku uint32) (c2 mm_domain.CartItemDiff, err error) {
	mm_atomic.AddUint64(&mmGetCartItem.beforeGetCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItem.afterGetCartItemCounter, 1)

	mmGetCartItem.t.Helper()

	if mmGetCartItem.inspectFuncGetCartItem != nil {
		mmGetCartItem.inspectFuncGetCartItem(ctx, user, sku)
	}

	mm_params := RepositoryMockGetCartItemParams{ctx, user, sku}

	// Record call args
	mmGetCartItem.GetCartItemMock.mutex.Lock()
	mmGetCartItem.GetCartItemMock.callArgs = append(mmGetCartItem.GetCartItemMock.callArgs, &mm_params)
	mmGetCartItem.GetCartItemMock.mutex.Unlock()

	for _, e := range mmGetCartItem.GetCartItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCartItem.GetCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItem.GetCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItem.GetCartItemMock.defaultExpectation.params
		mm_want_ptrs := mmGetCartItem.GetCartItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetCartItemParams{ctx, user, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCartItem.t.Errorf("RepositoryMock.GetCartItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartItem.GetCartItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmGetCartItem.t.Errorf("RepositoryMock.GetCartItem got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartItem.GetCartItemMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetCartItem.t.Errorf("RepositoryMock.GetCartItem got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartItem.GetCartItemMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItem.t.Errorf("RepositoryMock.GetCartItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCartItem.GetCartItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItem.GetCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItem.t.Fatal("No results are set for the RepositoryMock.GetCartItem")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetCartItem.funcGetCartItem != nil {
		return mmGetCartItem.funcGetCartItem(ctx, user, sku)
	}
	mmGetCartItem.t.Fatalf("Unexpected call to RepositoryMock.GetCartItem. %v %v %v", ctx, user, sku)
	return
}

// GetCartItemAfterCounter returns a count of finished RepositoryMock.GetCartItem invocations
func (mmGetCartItem *RepositoryMock) GetCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.afterGetCartItemCounter)
}

// GetCartItemBeforeCounter returns a count of RepositoryMock.GetCartItem invocations
func (mmGetCartItem *RepositoryMock) GetCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.beforeGetCartItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItem *mRepositoryMockGetCartItem) Calls() []*RepositoryMockGetCartItemParams {
	mmGetCartItem.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCartItemParams, len(mmGetCartItem.callArgs))
	copy(argCopy, mmGetCartItem.callArgs)

	mmGetCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemDone returns true if the count of the GetCartItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCartItemDone() bool {
	if m.GetCartItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartItemMock.invocationsDone()
}

// MinimockGetCartItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCartItemInspect() {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCartItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartItemCounter := mm_atomic.LoadUint64(&m.afterGetCartItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && afterGetCartItemCounter < 1 {
		if m.GetCartItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetCartItem at\n%s", m.GetCartItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCartItem at\n%s with params: %#v", m.GetCartItemMock.defaultExpectation.expectationOrigins.origin, *m.GetCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && afterGetCartItemCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetCartItem at\n%s", m.funcGetCartItemOrigin)
	}

	if !m.GetCartItemMock.invocationsDone() && afterGetCartItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetCartItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartItemMock.expectedInvocations), m.GetCartItemMock.expectedInvocationsOrigin, afterGetCartItemCounter)
	}
}

type mRepositoryMockListCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListCartExpectation
	expectations       []*RepositoryMockListCartExpectation

	callArgs []*RepositoryMockListCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListCartExpectation specifies expectation struct of the Repository.ListCart
type RepositoryMockListCartExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListCartParams
	paramPtrs          *RepositoryMockListCartParamPtrs
	expectationOrigins RepositoryMockListCartExpectationOrigins
	results            *RepositoryMockListCartResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListCartParams contains parameters of the Repository.ListCart
type RepositoryMockListCartParams struct {
	ctx  context.Context
	user int64
}

// RepositoryMockListCartParamPtrs contains pointers to parameters of the Repository.ListCart
type RepositoryMockListCartParamPtrs struct {
	ctx  *context.Context
	user *int64
}

// RepositoryMockListCartResults contains results of the Repository.ListCart
type RepositoryMockListCartResults struct {
	ca1 []mm_domain.CartItemDiff
	err error
}

// RepositoryMockListCartOrigins contains origins of expectations of the Repository.ListCart
type RepositoryMockListCartExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListCart *mRepositoryMockListCart) Optional() *mRepositoryMockListCart {
	mmListCart.optional = true
	return mmListCart
}

// Expect sets up expected params for Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Expect(ctx context.Context, user int64) *mRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &RepositoryMockListCartExpectation{}
	}

	if mmListCart.defaultExpectation.paramPtrs != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by ExpectParams functions")
	}

	mmListCart.defaultExpectation.params = &RepositoryMockListCartParams{ctx, user}
	mmListCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListCart.expectations {
		if minimock.Equal(e.params, mmListCart.defaultExpectation.params) {
			mmListCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCart.defaultExpectation.params)
		}
	}

	return mmListCart
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListCart
func (mmListCart *mRepositoryMockListCart) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &RepositoryMockListCartExpectation{}
	}

	if mmListCart.defaultExpectation.params != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Expect")
	}

	if mmListCart.defaultExpectation.paramPtrs == nil {
		mmListCart.defaultExpectation.paramPtrs = &RepositoryMockListCartParamPtrs{}
	}
	mmListCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmListCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListCart
}

// ExpectUserParam2 sets up expected param user for Repository.ListCart
func (mmListCart *mRepositoryMockListCart) ExpectUserParam2(user int64) *mRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &RepositoryMockListCartExpectation{}
	}

	if mmListCart.defaultExpectation.params != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Expect")
	}

	if mmListCart.defaultExpectation.paramPtrs == nil {
		mmListCart.defaultExpectation.paramPtrs = &RepositoryMockListCartParamPtrs{}
	}
	mmListCart.defaultExpectation.paramPtrs.user = &user
	mmListCart.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmListCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Inspect(f func(ctx context.Context, user int64)) *mRepositoryMockListCart {
	if mmListCart.mock.inspectFuncListCart != nil {
		mmListCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListCart")
	}

	mmListCart.mock.inspectFuncListCart = f

	return mmListCart
}

// Return sets up results that will be returned by Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Return(ca1 []mm_domain.CartItemDiff, err error) *RepositoryMock {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &RepositoryMockListCartExpectation{mock: mmListCart.mock}
	}
	mmListCart.defaultExpectation.results = &RepositoryMockListCartResults{ca1, err}
	mmListCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListCart.mock
}

// Set uses given function f to mock the Repository.ListCart method
func (mmListCart *mRepositoryMockListCart) Set(f func(ctx context.Context, user int64) (ca1 []mm_domain.CartItemDiff, err error)) *RepositoryMock {
	if mmListCart.defaultExpectation != nil {
		mmListCart.mock.t.Fatalf("Default expectation is already set for the Repository.ListCart method")
	}

	if len(mmListCart.expectations) > 0 {
		mmListCart.mock.t.Fatalf("Some expectations are already set for the Repository.ListCart method")
	}

	mmListCart.mock.funcListCart = f
	mmListCart.mock.funcListCartOrigin = minimock.CallerInfo(1)
	return mmListCart.mock
}

// When sets expectation for the Repository.ListCart which will trigger the result defined by the following
// Then helper
func (mmListCart *mRepositoryMockListCart) When(ctx context.Context, user int64) *RepositoryMockListCartExpectation {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	expectation := &RepositoryMockListCartExpectation{
		mock:               mmListCart.mock,
		params:             &RepositoryMockListCartParams{ctx, user},
		expectationOrigins: RepositoryMockListCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListCart.expectations = append(mmListCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListCartExpectation) Then(ca1 []mm_domain.CartItemDiff, err error) *RepositoryMock {
	e.results = &RepositoryMockListCartResults{ca1, err}
	return e.mock
}

// Times sets number of times Repository.ListCart should be invoked
func (mmListCart *mRepositoryMockListCart) Times(n uint64) *mRepositoryMockListCart {
	if n == 0 {
		mmListCart.mock.t.Fatalf("Times of RepositoryMock.ListCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListCart.expectedInvocations, n)
	mmListCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListCart
}

func (mmListCart *mRepositoryMockListCart) invocationsDone() bool {
	if len(mmListCart.expectations) == 0 && mmListCart.defaultExpectation == nil && mmListCart.mock.funcListCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListCart.mock.afterListCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListCart implements mm_domain.Repository
func (mmListCart *RepositoryMock) ListCart(ctx context.Context, user int64) (ca1 []mm_domain.CartItemDiff, err error) {
	mm_atomic.AddUint64(&mmListCart.beforeListCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListCart.afterListCartCounter, 1)

	mmListCart.t.Helper()

	if mmListCart.inspectFuncListCart != nil {
		mmListCart.inspectFuncListCart(ctx, user)
	}

	mm_params := RepositoryMockListCartParams{ctx, user}

	// Record call args
	mmListCart.ListCartMock.mutex.Lock()
	mmListCart.ListCartMock.callArgs = append(mmListCart.ListCartMock.callArgs, &mm_params)
	mmListCart.ListCartMock.mutex.Unlock()

	for _, e := range mmListCart.ListCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmListCart.ListCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCart.ListCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListCart.ListCartMock.defaultExpectation.params
		mm_want_ptrs := mmListCart.ListCartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListCartParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListCart.t.Errorf("RepositoryMock.ListCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCart.ListCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmListCart.t.Errorf("RepositoryMock.ListCart got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListCart.ListCartMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCart.t.Errorf("RepositoryMock.ListCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListCart.ListCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCart.ListCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListCart.t.Fatal("No results are set for the RepositoryMock.ListCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmListCart.funcListCart != nil {
		return mmListCart.funcListCart(ctx, user)
	}
	mmListCart.t.Fatalf("Unexpected call to RepositoryMock.ListCart. %v %v", ctx, user)
	return
}

// ListCartAfterCounter returns a count of finished RepositoryMock.ListCart invocations
func (mmListCart *RepositoryMock) ListCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.afterListCartCounter)
}

// ListCartBeforeCounter returns a count of RepositoryMock.ListCart invocations
func (mmListCart *RepositoryMock) ListCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.beforeListCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCart *mRepositoryMockListCart) Calls() []*RepositoryMockListCartParams {
	mmListCart.mutex.RLock()

	argCopy := make([]*RepositoryMockListCartParams, len(mmListCart.callArgs))
	copy(argCopy, mmListCart.callArgs)

	mmListCart.mutex.RUnlock()

	return argCopy
}

// MinimockListCartDone returns true if the count of the ListCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListCartDone() bool {
	if m.ListCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListCartMock.invocationsDone()
}

// MinimockListCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListCartInspect() {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCartCounter := mm_atomic.LoadUint64(&m.afterListCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && afterListCartCounter < 1 {
		if m.ListCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListCart at\n%s", m.ListCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListCart at\n%s with params: %#v", m.ListCartMock.defaultExpectation.expectationOrigins.origin, *m.ListCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && afterListCartCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListCart at\n%s", m.funcListCartOrigin)
	}

	if !m.ListCartMock.invocationsDone() && afterListCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListCartMock.expectedInvocations), m.ListCartMock.expectedInvocationsOrigin, afterListCartCounter)
	}
}

type mRepositoryMockUpdateCartItemCount struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateCartItemCountExpectation
	expectations       []*RepositoryMockUpdateCartItemCountExpectation

	callArgs []*RepositoryMockUpdateCartItemCountParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateCartItemCountExpectation specifies expectation struct of the Repository.UpdateCartItemCount
type RepositoryMockUpdateCartItemCountExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateCartItemCountParams
	paramPtrs          *RepositoryMockUpdateCartItemCountParamPtrs
	expectationOrigins RepositoryMockUpdateCartItemCountExpectationOrigins
	results            *RepositoryMockUpdateCartItemCountResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateCartItemCountParams contains parameters of the Repository.UpdateCartItemCount
type RepositoryMockUpdateCartItemCountParams struct {
	ctx      context.Context
	cartItem mm_domain.CartItemDiff
	newCount uint16
}

// RepositoryMockUpdateCartItemCountParamPtrs contains pointers to parameters of the Repository.UpdateCartItemCount
type RepositoryMockUpdateCartItemCountParamPtrs struct {
	ctx      *context.Context
	cartItem *mm_domain.CartItemDiff
	newCount *uint16
}

// RepositoryMockUpdateCartItemCountResults contains results of the Repository.UpdateCartItemCount
type RepositoryMockUpdateCartItemCountResults struct {
	err error
}

// RepositoryMockUpdateCartItemCountOrigins contains origins of expectations of the Repository.UpdateCartItemCount
type RepositoryMockUpdateCartItemCountExpectationOrigins struct {
	origin         string
	originCtx      string
	originCartItem string
	originNewCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Optional() *mRepositoryMockUpdateCartItemCount {
	mmUpdateCartItemCount.optional = true
	return mmUpdateCartItemCount
}

// Expect sets up expected params for Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Expect(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) *mRepositoryMockUpdateCartItemCount {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	if mmUpdateCartItemCount.defaultExpectation == nil {
		mmUpdateCartItemCount.defaultExpectation = &RepositoryMockUpdateCartItemCountExpectation{}
	}

	if mmUpdateCartItemCount.defaultExpectation.paramPtrs != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by ExpectParams functions")
	}

	mmUpdateCartItemCount.defaultExpectation.params = &RepositoryMockUpdateCartItemCountParams{ctx, cartItem, newCount}
	mmUpdateCartItemCount.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateCartItemCount.expectations {
		if minimock.Equal(e.params, mmUpdateCartItemCount.defaultExpectation.params) {
			mmUpdateCartItemCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCartItemCount.defaultExpectation.params)
		}
	}

	return mmUpdateCartItemCount
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateCartItemCount {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	if mmUpdateCartItemCount.defaultExpectation == nil {
		mmUpdateCartItemCount.defaultExpectation = &RepositoryMockUpdateCartItemCountExpectation{}
	}

	if mmUpdateCartItemCount.defaultExpectation.params != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Expect")
	}

	if mmUpdateCartItemCount.defaultExpectation.paramPtrs == nil {
		mmUpdateCartItemCount.defaultExpectation.paramPtrs = &RepositoryMockUpdateCartItemCountParamPtrs{}
	}
	mmUpdateCartItemCount.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateCartItemCount.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateCartItemCount
}

// ExpectCartItemParam2 sets up expected param cartItem for Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) ExpectCartItemParam2(cartItem mm_domain.CartItemDiff) *mRepositoryMockUpdateCartItemCount {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	if mmUpdateCartItemCount.defaultExpectation == nil {
		mmUpdateCartItemCount.defaultExpectation = &RepositoryMockUpdateCartItemCountExpectation{}
	}

	if mmUpdateCartItemCount.defaultExpectation.params != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Expect")
	}

	if mmUpdateCartItemCount.defaultExpectation.paramPtrs == nil {
		mmUpdateCartItemCount.defaultExpectation.paramPtrs = &RepositoryMockUpdateCartItemCountParamPtrs{}
	}
	mmUpdateCartItemCount.defaultExpectation.paramPtrs.cartItem = &cartItem
	mmUpdateCartItemCount.defaultExpectation.expectationOrigins.originCartItem = minimock.CallerInfo(1)

	return mmUpdateCartItemCount
}

// ExpectNewCountParam3 sets up expected param newCount for Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) ExpectNewCountParam3(newCount uint16) *mRepositoryMockUpdateCartItemCount {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	if mmUpdateCartItemCount.defaultExpectation == nil {
		mmUpdateCartItemCount.defaultExpectation = &RepositoryMockUpdateCartItemCountExpectation{}
	}

	if mmUpdateCartItemCount.defaultExpectation.params != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Expect")
	}

	if mmUpdateCartItemCount.defaultExpectation.paramPtrs == nil {
		mmUpdateCartItemCount.defaultExpectation.paramPtrs = &RepositoryMockUpdateCartItemCountParamPtrs{}
	}
	mmUpdateCartItemCount.defaultExpectation.paramPtrs.newCount = &newCount
	mmUpdateCartItemCount.defaultExpectation.expectationOrigins.originNewCount = minimock.CallerInfo(1)

	return mmUpdateCartItemCount
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Inspect(f func(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16)) *mRepositoryMockUpdateCartItemCount {
	if mmUpdateCartItemCount.mock.inspectFuncUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateCartItemCount")
	}

	mmUpdateCartItemCount.mock.inspectFuncUpdateCartItemCount = f

	return mmUpdateCartItemCount
}

// Return sets up results that will be returned by Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Return(err error) *RepositoryMock {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	if mmUpdateCartItemCount.defaultExpectation == nil {
		mmUpdateCartItemCount.defaultExpectation = &RepositoryMockUpdateCartItemCountExpectation{mock: mmUpdateCartItemCount.mock}
	}
	mmUpdateCartItemCount.defaultExpectation.results = &RepositoryMockUpdateCartItemCountResults{err}
	mmUpdateCartItemCount.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateCartItemCount.mock
}

// Set uses given function f to mock the Repository.UpdateCartItemCount method
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Set(f func(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) (err error)) *RepositoryMock {
	if mmUpdateCartItemCount.defaultExpectation != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateCartItemCount method")
	}

	if len(mmUpdateCartItemCount.expectations) > 0 {
		mmUpdateCartItemCount.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateCartItemCount method")
	}

	mmUpdateCartItemCount.mock.funcUpdateCartItemCount = f
	mmUpdateCartItemCount.mock.funcUpdateCartItemCountOrigin = minimock.CallerInfo(1)
	return mmUpdateCartItemCount.mock
}

// When sets expectation for the Repository.UpdateCartItemCount which will trigger the result defined by the following
// Then helper
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) When(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) *RepositoryMockUpdateCartItemCountExpectation {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateCartItemCountExpectation{
		mock:               mmUpdateCartItemCount.mock,
		params:             &RepositoryMockUpdateCartItemCountParams{ctx, cartItem, newCount},
		expectationOrigins: RepositoryMockUpdateCartItemCountExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateCartItemCount.expectations = append(mmUpdateCartItemCount.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateCartItemCount return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateCartItemCountExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateCartItemCountResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateCartItemCount should be invoked
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Times(n uint64) *mRepositoryMockUpdateCartItemCount {
	if n == 0 {
		mmUpdateCartItemCount.mock.t.Fatalf("Times of RepositoryMock.UpdateCartItemCount mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCartItemCount.expectedInvocations, n)
	mmUpdateCartItemCount.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateCartItemCount
}

func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) invocationsDone() bool {
	if len(mmUpdateCartItemCount.expectations) == 0 && mmUpdateCartItemCount.defaultExpectation == nil && mmUpdateCartItemCount.mock.funcUpdateCartItemCount == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCartItemCount.mock.afterUpdateCartItemCountCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCartItemCount.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCartItemCount implements mm_domain.Repository
func (mmUpdateCartItemCount *RepositoryMock) UpdateCartItemCount(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) (err error) {
	mm_atomic.AddUint64(&mmUpdateCartItemCount.beforeUpdateCartItemCountCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCartItemCount.afterUpdateCartItemCountCounter, 1)

	mmUpdateCartItemCount.t.Helper()

	if mmUpdateCartItemCount.inspectFuncUpdateCartItemCount != nil {
		mmUpdateCartItemCount.inspectFuncUpdateCartItemCount(ctx, cartItem, newCount)
	}

	mm_params := RepositoryMockUpdateCartItemCountParams{ctx, cartItem, newCount}

	// Record call args
	mmUpdateCartItemCount.UpdateCartItemCountMock.mutex.Lock()
	mmUpdateCartItemCount.UpdateCartItemCountMock.callArgs = append(mmUpdateCartItemCount.UpdateCartItemCountMock.callArgs, &mm_params)
	mmUpdateCartItemCount.UpdateCartItemCountMock.mutex.Unlock()

	for _, e := range mmUpdateCartItemCount.UpdateCartItemCountMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateCartItemCountParams{ctx, cartItem, newCount}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCartItemCount.t.Errorf("RepositoryMock.UpdateCartItemCount got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.cartItem != nil && !minimock.Equal(*mm_want_ptrs.cartItem, mm_got.cartItem) {
				mmUpdateCartItemCount.t.Errorf("RepositoryMock.UpdateCartItemCount got unexpected parameter cartItem, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.expectationOrigins.originCartItem, *mm_want_ptrs.cartItem, mm_got.cartItem, minimock.Diff(*mm_want_ptrs.cartItem, mm_got.cartItem))
			}

			if mm_want_ptrs.newCount != nil && !minimock.Equal(*mm_want_ptrs.newCount, mm_got.newCount) {
				mmUpdateCartItemCount.t.Errorf("RepositoryMock.UpdateCartItemCount got unexpected parameter newCount, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.expectationOrigins.originNewCount, *mm_want_ptrs.newCount, mm_got.newCount, minimock.Diff(*mm_want_ptrs.newCount, mm_got.newCount))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCartItemCount.t.Errorf("RepositoryMock.UpdateCartItemCount got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCartItemCount.t.Fatal("No results are set for the RepositoryMock.UpdateCartItemCount")
		}
		return (*mm_results).err
	}
	if mmUpdateCartItemCount.funcUpdateCartItemCount != nil {
		return mmUpdateCartItemCount.funcUpdateCartItemCount(ctx, cartItem, newCount)
	}
	mmUpdateCartItemCount.t.Fatalf("Unexpected call to RepositoryMock.UpdateCartItemCount. %v %v %v", ctx, cartItem, newCount)
	return
}

// UpdateCartItemCountAfterCounter returns a count of finished RepositoryMock.UpdateCartItemCount invocations
func (mmUpdateCartItemCount *RepositoryMock) UpdateCartItemCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartItemCount.afterUpdateCartItemCountCounter)
}

// UpdateCartItemCountBeforeCounter returns a count of RepositoryMock.UpdateCartItemCount invocations
func (mmUpdateCartItemCount *RepositoryMock) UpdateCartItemCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartItemCount.beforeUpdateCartItemCountCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateCartItemCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Calls() []*RepositoryMockUpdateCartItemCountParams {
	mmUpdateCartItemCount.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateCartItemCountParams, len(mmUpdateCartItemCount.callArgs))
	copy(argCopy, mmUpdateCartItemCount.callArgs)

	mmUpdateCartItemCount.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCartItemCountDone returns true if the count of the UpdateCartItemCount invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateCartItemCountDone() bool {
	if m.UpdateCartItemCountMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCartItemCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCartItemCountMock.invocationsDone()
}

// MinimockUpdateCartItemCountInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateCartItemCountInspect() {
	for _, e := range m.UpdateCartItemCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCartItemCount at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCartItemCountCounter := mm_atomic.LoadUint64(&m.afterUpdateCartItemCountCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartItemCountMock.defaultExpectation != nil && afterUpdateCartItemCountCounter < 1 {
		if m.UpdateCartItemCountMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCartItemCount at\n%s", m.UpdateCartItemCountMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCartItemCount at\n%s with params: %#v", m.UpdateCartItemCountMock.defaultExpectation.expectationOrigins.origin, *m.UpdateCartItemCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartItemCount != nil && afterUpdateCartItemCountCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateCartItemCount at\n%s", m.funcUpdateCartItemCountOrigin)
	}

	if !m.UpdateCartItemCountMock.invocationsDone() && afterUpdateCartItemCountCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateCartItemCount at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCartItemCountMock.expectedInvocations), m.UpdateCartItemCountMock.expectedInvocationsOrigin, afterUpdateCartItemCountCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateCartItemInspect()

			m.MinimockDeleteCartInspect()

			m.MinimockDeleteFromCartInspect()

			m.MinimockGetCartItemInspect()

			m.MinimockListCartInspect()

			m.MinimockUpdateCartItemCountInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCartItemDone() &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockGetCartItemDone() &&
		m.MinimockListCartDone() &&
		m.MinimockUpdateCartItemCountDone()
}
