package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain.Repository -o ./mocks/repository_minimock.go -n RepositoryMock

import (
	"context"
	mm_domain "route256/checkout/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements domain.Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateCartItem          func(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error)
	inspectFuncCreateCartItem   func(ctx context.Context, cartItem mm_domain.CartItemDiff)
	afterCreateCartItemCounter  uint64
	beforeCreateCartItemCounter uint64
	CreateCartItemMock          mRepositoryMockCreateCartItem

	funcDeleteCart          func(ctx context.Context, user int64) (err error)
	inspectFuncDeleteCart   func(ctx context.Context, user int64)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mRepositoryMockDeleteCart

	funcDeleteFromCart          func(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error)
	inspectFuncDeleteFromCart   func(ctx context.Context, cartItem mm_domain.CartItemDiff)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mRepositoryMockDeleteFromCart

	funcGetCartItem          func(ctx context.Context, user int64, sku uint32) (c2 mm_domain.CartItemDiff, err error)
	inspectFuncGetCartItem   func(ctx context.Context, user int64, sku uint32)
	afterGetCartItemCounter  uint64
	beforeGetCartItemCounter uint64
	GetCartItemMock          mRepositoryMockGetCartItem

	funcListCart          func(ctx context.Context, user int64) (ca1 []mm_domain.CartItemDiff, err error)
	inspectFuncListCart   func(ctx context.Context, user int64)
	afterListCartCounter  uint64
	beforeListCartCounter uint64
	ListCartMock          mRepositoryMockListCart

	funcUpdateCartItemCount          func(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) (err error)
	inspectFuncUpdateCartItemCount   func(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16)
	afterUpdateCartItemCountCounter  uint64
	beforeUpdateCartItemCountCounter uint64
	UpdateCartItemCountMock          mRepositoryMockUpdateCartItemCount
}

// NewRepositoryMock returns a mock for domain.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCartItemMock = mRepositoryMockCreateCartItem{mock: m}
	m.CreateCartItemMock.callArgs = []*RepositoryMockCreateCartItemParams{}

	m.DeleteCartMock = mRepositoryMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*RepositoryMockDeleteCartParams{}

	m.DeleteFromCartMock = mRepositoryMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*RepositoryMockDeleteFromCartParams{}

	m.GetCartItemMock = mRepositoryMockGetCartItem{mock: m}
	m.GetCartItemMock.callArgs = []*RepositoryMockGetCartItemParams{}

	m.ListCartMock = mRepositoryMockListCart{mock: m}
	m.ListCartMock.callArgs = []*RepositoryMockListCartParams{}

	m.UpdateCartItemCountMock = mRepositoryMockUpdateCartItemCount{mock: m}
	m.UpdateCartItemCountMock.callArgs = []*RepositoryMockUpdateCartItemCountParams{}

	return m
}

type mRepositoryMockCreateCartItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateCartItemExpectation
	expectations       []*RepositoryMockCreateCartItemExpectation

	callArgs []*RepositoryMockCreateCartItemParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateCartItemExpectation specifies expectation struct of the Repository.CreateCartItem
type RepositoryMockCreateCartItemExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateCartItemParams
	results *RepositoryMockCreateCartItemResults
	Counter uint64
}

// RepositoryMockCreateCartItemParams contains parameters of the Repository.CreateCartItem
type RepositoryMockCreateCartItemParams struct {
	ctx      context.Context
	cartItem mm_domain.CartItemDiff
}

// RepositoryMockCreateCartItemResults contains results of the Repository.CreateCartItem
type RepositoryMockCreateCartItemResults struct {
	err error
}

// Expect sets up expected params for Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Expect(ctx context.Context, cartItem mm_domain.CartItemDiff) *mRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &RepositoryMockCreateCartItemExpectation{}
	}

	mmCreateCartItem.defaultExpectation.params = &RepositoryMockCreateCartItemParams{ctx, cartItem}
	for _, e := range mmCreateCartItem.expectations {
		if minimock.Equal(e.params, mmCreateCartItem.defaultExpectation.params) {
			mmCreateCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateCartItem.defaultExpectation.params)
		}
	}

	return mmCreateCartItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Inspect(f func(ctx context.Context, cartItem mm_domain.CartItemDiff)) *mRepositoryMockCreateCartItem {
	if mmCreateCartItem.mock.inspectFuncCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateCartItem")
	}

	mmCreateCartItem.mock.inspectFuncCreateCartItem = f

	return mmCreateCartItem
}

// Return sets up results that will be returned by Repository.CreateCartItem
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Return(err error) *RepositoryMock {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	if mmCreateCartItem.defaultExpectation == nil {
		mmCreateCartItem.defaultExpectation = &RepositoryMockCreateCartItemExpectation{mock: mmCreateCartItem.mock}
	}
	mmCreateCartItem.defaultExpectation.results = &RepositoryMockCreateCartItemResults{err}
	return mmCreateCartItem.mock
}

// Set uses given function f to mock the Repository.CreateCartItem method
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Set(f func(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error)) *RepositoryMock {
	if mmCreateCartItem.defaultExpectation != nil {
		mmCreateCartItem.mock.t.Fatalf("Default expectation is already set for the Repository.CreateCartItem method")
	}

	if len(mmCreateCartItem.expectations) > 0 {
		mmCreateCartItem.mock.t.Fatalf("Some expectations are already set for the Repository.CreateCartItem method")
	}

	mmCreateCartItem.mock.funcCreateCartItem = f
	return mmCreateCartItem.mock
}

// When sets expectation for the Repository.CreateCartItem which will trigger the result defined by the following
// Then helper
func (mmCreateCartItem *mRepositoryMockCreateCartItem) When(ctx context.Context, cartItem mm_domain.CartItemDiff) *RepositoryMockCreateCartItemExpectation {
	if mmCreateCartItem.mock.funcCreateCartItem != nil {
		mmCreateCartItem.mock.t.Fatalf("RepositoryMock.CreateCartItem mock is already set by Set")
	}

	expectation := &RepositoryMockCreateCartItemExpectation{
		mock:   mmCreateCartItem.mock,
		params: &RepositoryMockCreateCartItemParams{ctx, cartItem},
	}
	mmCreateCartItem.expectations = append(mmCreateCartItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateCartItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateCartItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateCartItemResults{err}
	return e.mock
}

// CreateCartItem implements domain.Repository
func (mmCreateCartItem *RepositoryMock) CreateCartItem(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error) {
	mm_atomic.AddUint64(&mmCreateCartItem.beforeCreateCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateCartItem.afterCreateCartItemCounter, 1)

	if mmCreateCartItem.inspectFuncCreateCartItem != nil {
		mmCreateCartItem.inspectFuncCreateCartItem(ctx, cartItem)
	}

	mm_params := &RepositoryMockCreateCartItemParams{ctx, cartItem}

	// Record call args
	mmCreateCartItem.CreateCartItemMock.mutex.Lock()
	mmCreateCartItem.CreateCartItemMock.callArgs = append(mmCreateCartItem.CreateCartItemMock.callArgs, mm_params)
	mmCreateCartItem.CreateCartItemMock.mutex.Unlock()

	for _, e := range mmCreateCartItem.CreateCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateCartItem.CreateCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateCartItem.CreateCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateCartItem.CreateCartItemMock.defaultExpectation.params
		mm_got := RepositoryMockCreateCartItemParams{ctx, cartItem}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateCartItem.t.Errorf("RepositoryMock.CreateCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateCartItem.CreateCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateCartItem.t.Fatal("No results are set for the RepositoryMock.CreateCartItem")
		}
		return (*mm_results).err
	}
	if mmCreateCartItem.funcCreateCartItem != nil {
		return mmCreateCartItem.funcCreateCartItem(ctx, cartItem)
	}
	mmCreateCartItem.t.Fatalf("Unexpected call to RepositoryMock.CreateCartItem. %v %v", ctx, cartItem)
	return
}

// CreateCartItemAfterCounter returns a count of finished RepositoryMock.CreateCartItem invocations
func (mmCreateCartItem *RepositoryMock) CreateCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCartItem.afterCreateCartItemCounter)
}

// CreateCartItemBeforeCounter returns a count of RepositoryMock.CreateCartItem invocations
func (mmCreateCartItem *RepositoryMock) CreateCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateCartItem.beforeCreateCartItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateCartItem *mRepositoryMockCreateCartItem) Calls() []*RepositoryMockCreateCartItemParams {
	mmCreateCartItem.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateCartItemParams, len(mmCreateCartItem.callArgs))
	copy(argCopy, mmCreateCartItem.callArgs)

	mmCreateCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCartItemDone returns true if the count of the CreateCartItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateCartItemDone() bool {
	for _, e := range m.CreateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCartItem != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateCartItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateCartItemInspect() {
	for _, e := range m.CreateCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		if m.CreateCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateCartItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateCartItem with params: %#v", *m.CreateCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateCartItem != nil && mm_atomic.LoadUint64(&m.afterCreateCartItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateCartItem")
	}
}

type mRepositoryMockDeleteCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteCartExpectation
	expectations       []*RepositoryMockDeleteCartExpectation

	callArgs []*RepositoryMockDeleteCartParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteCartExpectation specifies expectation struct of the Repository.DeleteCart
type RepositoryMockDeleteCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteCartParams
	results *RepositoryMockDeleteCartResults
	Counter uint64
}

// RepositoryMockDeleteCartParams contains parameters of the Repository.DeleteCart
type RepositoryMockDeleteCartParams struct {
	ctx  context.Context
	user int64
}

// RepositoryMockDeleteCartResults contains results of the Repository.DeleteCart
type RepositoryMockDeleteCartResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteCart
func (mmDeleteCart *mRepositoryMockDeleteCart) Expect(ctx context.Context, user int64) *mRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &RepositoryMockDeleteCartExpectation{}
	}

	mmDeleteCart.defaultExpectation.params = &RepositoryMockDeleteCartParams{ctx, user}
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteCart
func (mmDeleteCart *mRepositoryMockDeleteCart) Inspect(f func(ctx context.Context, user int64)) *mRepositoryMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by Repository.DeleteCart
func (mmDeleteCart *mRepositoryMockDeleteCart) Return(err error) *RepositoryMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &RepositoryMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &RepositoryMockDeleteCartResults{err}
	return mmDeleteCart.mock
}

// Set uses given function f to mock the Repository.DeleteCart method
func (mmDeleteCart *mRepositoryMockDeleteCart) Set(f func(ctx context.Context, user int64) (err error)) *RepositoryMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	return mmDeleteCart.mock
}

// When sets expectation for the Repository.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mRepositoryMockDeleteCart) When(ctx context.Context, user int64) *RepositoryMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("RepositoryMock.DeleteCart mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteCartExpectation{
		mock:   mmDeleteCart.mock,
		params: &RepositoryMockDeleteCartParams{ctx, user},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteCartResults{err}
	return e.mock
}

// DeleteCart implements domain.Repository
func (mmDeleteCart *RepositoryMock) DeleteCart(ctx context.Context, user int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, user)
	}

	mm_params := &RepositoryMockDeleteCartParams{ctx, user}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("RepositoryMock.DeleteCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the RepositoryMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, user)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to RepositoryMock.DeleteCart. %v %v", ctx, user)
	return
}

// DeleteCartAfterCounter returns a count of finished RepositoryMock.DeleteCart invocations
func (mmDeleteCart *RepositoryMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of RepositoryMock.DeleteCart invocations
func (mmDeleteCart *RepositoryMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mRepositoryMockDeleteCart) Calls() []*RepositoryMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteCartDone() bool {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteCart with params: %#v", *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteCart")
	}
}

type mRepositoryMockDeleteFromCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteFromCartExpectation
	expectations       []*RepositoryMockDeleteFromCartExpectation

	callArgs []*RepositoryMockDeleteFromCartParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteFromCartExpectation specifies expectation struct of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteFromCartParams
	results *RepositoryMockDeleteFromCartResults
	Counter uint64
}

// RepositoryMockDeleteFromCartParams contains parameters of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartParams struct {
	ctx      context.Context
	cartItem mm_domain.CartItemDiff
}

// RepositoryMockDeleteFromCartResults contains results of the Repository.DeleteFromCart
type RepositoryMockDeleteFromCartResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Expect(ctx context.Context, cartItem mm_domain.CartItemDiff) *mRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &RepositoryMockDeleteFromCartExpectation{}
	}

	mmDeleteFromCart.defaultExpectation.params = &RepositoryMockDeleteFromCartParams{ctx, cartItem}
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Inspect(f func(ctx context.Context, cartItem mm_domain.CartItemDiff)) *mRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by Repository.DeleteFromCart
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Return(err error) *RepositoryMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &RepositoryMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &RepositoryMockDeleteFromCartResults{err}
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the Repository.DeleteFromCart method
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Set(f func(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error)) *RepositoryMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	return mmDeleteFromCart.mock
}

// When sets expectation for the Repository.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) When(ctx context.Context, cartItem mm_domain.CartItemDiff) *RepositoryMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("RepositoryMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteFromCartExpectation{
		mock:   mmDeleteFromCart.mock,
		params: &RepositoryMockDeleteFromCartParams{ctx, cartItem},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteFromCartExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteFromCartResults{err}
	return e.mock
}

// DeleteFromCart implements domain.Repository
func (mmDeleteFromCart *RepositoryMock) DeleteFromCart(ctx context.Context, cartItem mm_domain.CartItemDiff) (err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, cartItem)
	}

	mm_params := &RepositoryMockDeleteFromCartParams{ctx, cartItem}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteFromCartParams{ctx, cartItem}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("RepositoryMock.DeleteFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the RepositoryMock.DeleteFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, cartItem)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to RepositoryMock.DeleteFromCart. %v %v", ctx, cartItem)
	return
}

// DeleteFromCartAfterCounter returns a count of finished RepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *RepositoryMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of RepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *RepositoryMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mRepositoryMockDeleteFromCart) Calls() []*RepositoryMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteFromCartDone() bool {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteFromCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteFromCart with params: %#v", *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteFromCart")
	}
}

type mRepositoryMockGetCartItem struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetCartItemExpectation
	expectations       []*RepositoryMockGetCartItemExpectation

	callArgs []*RepositoryMockGetCartItemParams
	mutex    sync.RWMutex
}

// RepositoryMockGetCartItemExpectation specifies expectation struct of the Repository.GetCartItem
type RepositoryMockGetCartItemExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetCartItemParams
	results *RepositoryMockGetCartItemResults
	Counter uint64
}

// RepositoryMockGetCartItemParams contains parameters of the Repository.GetCartItem
type RepositoryMockGetCartItemParams struct {
	ctx  context.Context
	user int64
	sku  uint32
}

// RepositoryMockGetCartItemResults contains results of the Repository.GetCartItem
type RepositoryMockGetCartItemResults struct {
	c2  mm_domain.CartItemDiff
	err error
}

// Expect sets up expected params for Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) Expect(ctx context.Context, user int64, sku uint32) *mRepositoryMockGetCartItem {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &RepositoryMockGetCartItemExpectation{}
	}

	mmGetCartItem.defaultExpectation.params = &RepositoryMockGetCartItemParams{ctx, user, sku}
	for _, e := range mmGetCartItem.expectations {
		if minimock.Equal(e.params, mmGetCartItem.defaultExpectation.params) {
			mmGetCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItem.defaultExpectation.params)
		}
	}

	return mmGetCartItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) Inspect(f func(ctx context.Context, user int64, sku uint32)) *mRepositoryMockGetCartItem {
	if mmGetCartItem.mock.inspectFuncGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetCartItem")
	}

	mmGetCartItem.mock.inspectFuncGetCartItem = f

	return mmGetCartItem
}

// Return sets up results that will be returned by Repository.GetCartItem
func (mmGetCartItem *mRepositoryMockGetCartItem) Return(c2 mm_domain.CartItemDiff, err error) *RepositoryMock {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &RepositoryMockGetCartItemExpectation{mock: mmGetCartItem.mock}
	}
	mmGetCartItem.defaultExpectation.results = &RepositoryMockGetCartItemResults{c2, err}
	return mmGetCartItem.mock
}

// Set uses given function f to mock the Repository.GetCartItem method
func (mmGetCartItem *mRepositoryMockGetCartItem) Set(f func(ctx context.Context, user int64, sku uint32) (c2 mm_domain.CartItemDiff, err error)) *RepositoryMock {
	if mmGetCartItem.defaultExpectation != nil {
		mmGetCartItem.mock.t.Fatalf("Default expectation is already set for the Repository.GetCartItem method")
	}

	if len(mmGetCartItem.expectations) > 0 {
		mmGetCartItem.mock.t.Fatalf("Some expectations are already set for the Repository.GetCartItem method")
	}

	mmGetCartItem.mock.funcGetCartItem = f
	return mmGetCartItem.mock
}

// When sets expectation for the Repository.GetCartItem which will trigger the result defined by the following
// Then helper
func (mmGetCartItem *mRepositoryMockGetCartItem) When(ctx context.Context, user int64, sku uint32) *RepositoryMockGetCartItemExpectation {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("RepositoryMock.GetCartItem mock is already set by Set")
	}

	expectation := &RepositoryMockGetCartItemExpectation{
		mock:   mmGetCartItem.mock,
		params: &RepositoryMockGetCartItemParams{ctx, user, sku},
	}
	mmGetCartItem.expectations = append(mmGetCartItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetCartItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetCartItemExpectation) Then(c2 mm_domain.CartItemDiff, err error) *RepositoryMock {
	e.results = &RepositoryMockGetCartItemResults{c2, err}
	return e.mock
}

// GetCartItem implements domain.Repository
func (mmGetCartItem *RepositoryMock) GetCartItem(ctx context.Context, user int64, sku uint32) (c2 mm_domain.CartItemDiff, err error) {
	mm_atomic.AddUint64(&mmGetCartItem.beforeGetCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItem.afterGetCartItemCounter, 1)

	if mmGetCartItem.inspectFuncGetCartItem != nil {
		mmGetCartItem.inspectFuncGetCartItem(ctx, user, sku)
	}

	mm_params := &RepositoryMockGetCartItemParams{ctx, user, sku}

	// Record call args
	mmGetCartItem.GetCartItemMock.mutex.Lock()
	mmGetCartItem.GetCartItemMock.callArgs = append(mmGetCartItem.GetCartItemMock.callArgs, mm_params)
	mmGetCartItem.GetCartItemMock.mutex.Unlock()

	for _, e := range mmGetCartItem.GetCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCartItem.GetCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItem.GetCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItem.GetCartItemMock.defaultExpectation.params
		mm_got := RepositoryMockGetCartItemParams{ctx, user, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItem.t.Errorf("RepositoryMock.GetCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItem.GetCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItem.t.Fatal("No results are set for the RepositoryMock.GetCartItem")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetCartItem.funcGetCartItem != nil {
		return mmGetCartItem.funcGetCartItem(ctx, user, sku)
	}
	mmGetCartItem.t.Fatalf("Unexpected call to RepositoryMock.GetCartItem. %v %v %v", ctx, user, sku)
	return
}

// GetCartItemAfterCounter returns a count of finished RepositoryMock.GetCartItem invocations
func (mmGetCartItem *RepositoryMock) GetCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.afterGetCartItemCounter)
}

// GetCartItemBeforeCounter returns a count of RepositoryMock.GetCartItem invocations
func (mmGetCartItem *RepositoryMock) GetCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.beforeGetCartItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItem *mRepositoryMockGetCartItem) Calls() []*RepositoryMockGetCartItemParams {
	mmGetCartItem.mutex.RLock()

	argCopy := make([]*RepositoryMockGetCartItemParams, len(mmGetCartItem.callArgs))
	copy(argCopy, mmGetCartItem.callArgs)

	mmGetCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemDone returns true if the count of the GetCartItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetCartItemDone() bool {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetCartItemInspect() {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		if m.GetCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetCartItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetCartItem with params: %#v", *m.GetCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetCartItem")
	}
}

type mRepositoryMockListCart struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListCartExpectation
	expectations       []*RepositoryMockListCartExpectation

	callArgs []*RepositoryMockListCartParams
	mutex    sync.RWMutex
}

// RepositoryMockListCartExpectation specifies expectation struct of the Repository.ListCart
type RepositoryMockListCartExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockListCartParams
	results *RepositoryMockListCartResults
	Counter uint64
}

// RepositoryMockListCartParams contains parameters of the Repository.ListCart
type RepositoryMockListCartParams struct {
	ctx  context.Context
	user int64
}

// RepositoryMockListCartResults contains results of the Repository.ListCart
type RepositoryMockListCartResults struct {
	ca1 []mm_domain.CartItemDiff
	err error
}

// Expect sets up expected params for Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Expect(ctx context.Context, user int64) *mRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &RepositoryMockListCartExpectation{}
	}

	mmListCart.defaultExpectation.params = &RepositoryMockListCartParams{ctx, user}
	for _, e := range mmListCart.expectations {
		if minimock.Equal(e.params, mmListCart.defaultExpectation.params) {
			mmListCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCart.defaultExpectation.params)
		}
	}

	return mmListCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Inspect(f func(ctx context.Context, user int64)) *mRepositoryMockListCart {
	if mmListCart.mock.inspectFuncListCart != nil {
		mmListCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListCart")
	}

	mmListCart.mock.inspectFuncListCart = f

	return mmListCart
}

// Return sets up results that will be returned by Repository.ListCart
func (mmListCart *mRepositoryMockListCart) Return(ca1 []mm_domain.CartItemDiff, err error) *RepositoryMock {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &RepositoryMockListCartExpectation{mock: mmListCart.mock}
	}
	mmListCart.defaultExpectation.results = &RepositoryMockListCartResults{ca1, err}
	return mmListCart.mock
}

// Set uses given function f to mock the Repository.ListCart method
func (mmListCart *mRepositoryMockListCart) Set(f func(ctx context.Context, user int64) (ca1 []mm_domain.CartItemDiff, err error)) *RepositoryMock {
	if mmListCart.defaultExpectation != nil {
		mmListCart.mock.t.Fatalf("Default expectation is already set for the Repository.ListCart method")
	}

	if len(mmListCart.expectations) > 0 {
		mmListCart.mock.t.Fatalf("Some expectations are already set for the Repository.ListCart method")
	}

	mmListCart.mock.funcListCart = f
	return mmListCart.mock
}

// When sets expectation for the Repository.ListCart which will trigger the result defined by the following
// Then helper
func (mmListCart *mRepositoryMockListCart) When(ctx context.Context, user int64) *RepositoryMockListCartExpectation {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("RepositoryMock.ListCart mock is already set by Set")
	}

	expectation := &RepositoryMockListCartExpectation{
		mock:   mmListCart.mock,
		params: &RepositoryMockListCartParams{ctx, user},
	}
	mmListCart.expectations = append(mmListCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListCart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListCartExpectation) Then(ca1 []mm_domain.CartItemDiff, err error) *RepositoryMock {
	e.results = &RepositoryMockListCartResults{ca1, err}
	return e.mock
}

// ListCart implements domain.Repository
func (mmListCart *RepositoryMock) ListCart(ctx context.Context, user int64) (ca1 []mm_domain.CartItemDiff, err error) {
	mm_atomic.AddUint64(&mmListCart.beforeListCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListCart.afterListCartCounter, 1)

	if mmListCart.inspectFuncListCart != nil {
		mmListCart.inspectFuncListCart(ctx, user)
	}

	mm_params := &RepositoryMockListCartParams{ctx, user}

	// Record call args
	mmListCart.ListCartMock.mutex.Lock()
	mmListCart.ListCartMock.callArgs = append(mmListCart.ListCartMock.callArgs, mm_params)
	mmListCart.ListCartMock.mutex.Unlock()

	for _, e := range mmListCart.ListCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmListCart.ListCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCart.ListCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListCart.ListCartMock.defaultExpectation.params
		mm_got := RepositoryMockListCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCart.t.Errorf("RepositoryMock.ListCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCart.ListCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListCart.t.Fatal("No results are set for the RepositoryMock.ListCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmListCart.funcListCart != nil {
		return mmListCart.funcListCart(ctx, user)
	}
	mmListCart.t.Fatalf("Unexpected call to RepositoryMock.ListCart. %v %v", ctx, user)
	return
}

// ListCartAfterCounter returns a count of finished RepositoryMock.ListCart invocations
func (mmListCart *RepositoryMock) ListCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.afterListCartCounter)
}

// ListCartBeforeCounter returns a count of RepositoryMock.ListCart invocations
func (mmListCart *RepositoryMock) ListCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.beforeListCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCart *mRepositoryMockListCart) Calls() []*RepositoryMockListCartParams {
	mmListCart.mutex.RLock()

	argCopy := make([]*RepositoryMockListCartParams, len(mmListCart.callArgs))
	copy(argCopy, mmListCart.callArgs)

	mmListCart.mutex.RUnlock()

	return argCopy
}

// MinimockListCartDone returns true if the count of the ListCart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListCartDone() bool {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockListCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListCartInspect() {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		if m.ListCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListCart")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListCart with params: %#v", *m.ListCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ListCart")
	}
}

type mRepositoryMockUpdateCartItemCount struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateCartItemCountExpectation
	expectations       []*RepositoryMockUpdateCartItemCountExpectation

	callArgs []*RepositoryMockUpdateCartItemCountParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateCartItemCountExpectation specifies expectation struct of the Repository.UpdateCartItemCount
type RepositoryMockUpdateCartItemCountExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateCartItemCountParams
	results *RepositoryMockUpdateCartItemCountResults
	Counter uint64
}

// RepositoryMockUpdateCartItemCountParams contains parameters of the Repository.UpdateCartItemCount
type RepositoryMockUpdateCartItemCountParams struct {
	ctx      context.Context
	cartItem mm_domain.CartItemDiff
	newCount uint16
}

// RepositoryMockUpdateCartItemCountResults contains results of the Repository.UpdateCartItemCount
type RepositoryMockUpdateCartItemCountResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Expect(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) *mRepositoryMockUpdateCartItemCount {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	if mmUpdateCartItemCount.defaultExpectation == nil {
		mmUpdateCartItemCount.defaultExpectation = &RepositoryMockUpdateCartItemCountExpectation{}
	}

	mmUpdateCartItemCount.defaultExpectation.params = &RepositoryMockUpdateCartItemCountParams{ctx, cartItem, newCount}
	for _, e := range mmUpdateCartItemCount.expectations {
		if minimock.Equal(e.params, mmUpdateCartItemCount.defaultExpectation.params) {
			mmUpdateCartItemCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCartItemCount.defaultExpectation.params)
		}
	}

	return mmUpdateCartItemCount
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Inspect(f func(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16)) *mRepositoryMockUpdateCartItemCount {
	if mmUpdateCartItemCount.mock.inspectFuncUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateCartItemCount")
	}

	mmUpdateCartItemCount.mock.inspectFuncUpdateCartItemCount = f

	return mmUpdateCartItemCount
}

// Return sets up results that will be returned by Repository.UpdateCartItemCount
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Return(err error) *RepositoryMock {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	if mmUpdateCartItemCount.defaultExpectation == nil {
		mmUpdateCartItemCount.defaultExpectation = &RepositoryMockUpdateCartItemCountExpectation{mock: mmUpdateCartItemCount.mock}
	}
	mmUpdateCartItemCount.defaultExpectation.results = &RepositoryMockUpdateCartItemCountResults{err}
	return mmUpdateCartItemCount.mock
}

// Set uses given function f to mock the Repository.UpdateCartItemCount method
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Set(f func(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) (err error)) *RepositoryMock {
	if mmUpdateCartItemCount.defaultExpectation != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateCartItemCount method")
	}

	if len(mmUpdateCartItemCount.expectations) > 0 {
		mmUpdateCartItemCount.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateCartItemCount method")
	}

	mmUpdateCartItemCount.mock.funcUpdateCartItemCount = f
	return mmUpdateCartItemCount.mock
}

// When sets expectation for the Repository.UpdateCartItemCount which will trigger the result defined by the following
// Then helper
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) When(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) *RepositoryMockUpdateCartItemCountExpectation {
	if mmUpdateCartItemCount.mock.funcUpdateCartItemCount != nil {
		mmUpdateCartItemCount.mock.t.Fatalf("RepositoryMock.UpdateCartItemCount mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateCartItemCountExpectation{
		mock:   mmUpdateCartItemCount.mock,
		params: &RepositoryMockUpdateCartItemCountParams{ctx, cartItem, newCount},
	}
	mmUpdateCartItemCount.expectations = append(mmUpdateCartItemCount.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateCartItemCount return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateCartItemCountExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateCartItemCountResults{err}
	return e.mock
}

// UpdateCartItemCount implements domain.Repository
func (mmUpdateCartItemCount *RepositoryMock) UpdateCartItemCount(ctx context.Context, cartItem mm_domain.CartItemDiff, newCount uint16) (err error) {
	mm_atomic.AddUint64(&mmUpdateCartItemCount.beforeUpdateCartItemCountCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCartItemCount.afterUpdateCartItemCountCounter, 1)

	if mmUpdateCartItemCount.inspectFuncUpdateCartItemCount != nil {
		mmUpdateCartItemCount.inspectFuncUpdateCartItemCount(ctx, cartItem, newCount)
	}

	mm_params := &RepositoryMockUpdateCartItemCountParams{ctx, cartItem, newCount}

	// Record call args
	mmUpdateCartItemCount.UpdateCartItemCountMock.mutex.Lock()
	mmUpdateCartItemCount.UpdateCartItemCountMock.callArgs = append(mmUpdateCartItemCount.UpdateCartItemCountMock.callArgs, mm_params)
	mmUpdateCartItemCount.UpdateCartItemCountMock.mutex.Unlock()

	for _, e := range mmUpdateCartItemCount.UpdateCartItemCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateCartItemCountParams{ctx, cartItem, newCount}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCartItemCount.t.Errorf("RepositoryMock.UpdateCartItemCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCartItemCount.UpdateCartItemCountMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCartItemCount.t.Fatal("No results are set for the RepositoryMock.UpdateCartItemCount")
		}
		return (*mm_results).err
	}
	if mmUpdateCartItemCount.funcUpdateCartItemCount != nil {
		return mmUpdateCartItemCount.funcUpdateCartItemCount(ctx, cartItem, newCount)
	}
	mmUpdateCartItemCount.t.Fatalf("Unexpected call to RepositoryMock.UpdateCartItemCount. %v %v %v", ctx, cartItem, newCount)
	return
}

// UpdateCartItemCountAfterCounter returns a count of finished RepositoryMock.UpdateCartItemCount invocations
func (mmUpdateCartItemCount *RepositoryMock) UpdateCartItemCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartItemCount.afterUpdateCartItemCountCounter)
}

// UpdateCartItemCountBeforeCounter returns a count of RepositoryMock.UpdateCartItemCount invocations
func (mmUpdateCartItemCount *RepositoryMock) UpdateCartItemCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCartItemCount.beforeUpdateCartItemCountCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateCartItemCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCartItemCount *mRepositoryMockUpdateCartItemCount) Calls() []*RepositoryMockUpdateCartItemCountParams {
	mmUpdateCartItemCount.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateCartItemCountParams, len(mmUpdateCartItemCount.callArgs))
	copy(argCopy, mmUpdateCartItemCount.callArgs)

	mmUpdateCartItemCount.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCartItemCountDone returns true if the count of the UpdateCartItemCount invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateCartItemCountDone() bool {
	for _, e := range m.UpdateCartItemCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartItemCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartItemCount != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCartItemCountInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateCartItemCountInspect() {
	for _, e := range m.UpdateCartItemCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCartItemCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCartItemCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemCountCounter) < 1 {
		if m.UpdateCartItemCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateCartItemCount")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateCartItemCount with params: %#v", *m.UpdateCartItemCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCartItemCount != nil && mm_atomic.LoadUint64(&m.afterUpdateCartItemCountCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateCartItemCount")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateCartItemInspect()

		m.MinimockDeleteCartInspect()

		m.MinimockDeleteFromCartInspect()

		m.MinimockGetCartItemInspect()

		m.MinimockListCartInspect()

		m.MinimockUpdateCartItemCountInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCartItemDone() &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockGetCartItemDone() &&
		m.MinimockListCartDone() &&
		m.MinimockUpdateCartItemCountDone()
}
